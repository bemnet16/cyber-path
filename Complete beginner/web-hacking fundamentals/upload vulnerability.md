### Introduction
The ability to upload files to a server has become an integral part of how we interact with web applications. Be it a profile picture for a social media website, a report being uploaded to cloud storage, or saving a project on Github; the applications for file upload features are limitless.

Unfortunately, when handled badly, file uploads can also open up severe vulnerabilities in the server. This can lead to anything from relatively minor, nuisance problems; all the way up to full Remote Code Execution (RCE) if an attacker manages to upload and execute a shell.

some of the vulnerabilities resulting from improper (or inadequate) handling of file uploads will be:
- Overwriting existing files on a server
- Uploading and Executing Shells on a server  
- Bypassing Client-Side filtering
- Bypassing various kinds of Server-Side filtering
- Fooling content type validation checks

**Overwriting existing files** typically refers to the action of replacing the content of a file with new data. This can occur intentionally when you save changes to a file that already exists, or unintentionally when you perform file operations without checking for existing files.

**Remote Code Execution(RCE)** refers to the ability of an attacker to execute arbitrary code on a target system from a remote location. This is a severe security vulnerability that can have serious consequences, including unauthorized access to systems, data theft, system compromise, and more. RCE vulnerabilities typically arise due to flaws in software or systems that allow attackers to inject and execute malicious code remotely.

**Filtering** refers to the process of selecting or excluding specific elements from a set based on predefined criteria. It is commonly used in various contexts, including data analysis, information retrieval, signal processing, and security.
	_Extension Validation:_
	File extensions are used (in theory) to identify the contents of a file. In practice they are very easy to change, so actually don't mean much; however, MS Windows still uses them to identify file types, although Unix based systems tend to rely on other methods, which we'll cover in a bit. Filters that check for extensions work in one of two ways. They either _blacklist_ extensions (i.e. have a list of extensions which are **not** allowed) or they _whitelist_ extensions (i.e. have a list of extensions which **are** allowed, and reject everything else).
	_File Type Filtering:_
	Similar to Extension validation, but more intensive, file type filtering looks, once again, to verify that the contents of a file are acceptable to upload.
	_File Length Filtering:_
	File length filters are used to prevent huge files from being uploaded to the server via an upload form (as this can potentially starve the server of resources).
	_File Content Filtering:_
	More complicated filtering systems may scan the full contents of an uploaded file to ensure that it's not spoofing its extension, MIME type and Magic Number. This is a significantly more complex process than the majority of basic filtration systems.

As mentioned previously, client-side filtering tends to be extremely easy to bypass, as it occurs entirely on a machine that _you_ control. When you have access to the code, it's very easy to alter it.

#### Bypass client-side filtering
There are four easy ways to bypass your average client-side file upload filter:
1. _Turn off Javascript in your browser_ -- this will work provided the site doesn't require Javascript in order to provide basic functionality. If turning off Javascript completely will prevent the site from working at all then one of the other methods would be more desirable; otherwise, this can be an effective way of completely bypassing the client-side filter.

2. _Intercept and modify the incoming page._ Using Burpsuite, we can intercept the incoming web page and strip out the Javascript filter before it has a chance to run. The process for this will be covered below.
	steps:
	- Having established this, let's start [Burpsuite](https://blog.tryhackme.com/setting-up-burp/) and reload the page. We will see our own request to the site, but what we really want to see is the server's _response_, so right click on the intercepted data, scroll down to "Do Intercept", then select "Response to this request":
	- When we click the "Forward" button at the top of the window, we will then see the server's response to our request. Here we can delete, comment out, or otherwise break the Javascript function before it has a chance to load:  

		![](https://i.imgur.com/ACgWLpH.png)
		Having deleted the function, we once again click "Forward" until the site has finished loading, and are now free to upload any kind of file to the website:
		
3. _Intercept and modify the file upload_. Where the previous method works _before_ the webpage is loaded, this method allows the web page to load as normal, but intercepts the file upload after it's already passed (and been accepted by the filter). 
	 e.g: Once again we'll activate our Burpsuite intercept, then click "Upload" and catch the request:
	![](https://i.imgur.com/h2164Li.png)
	Observe that the MIME type of our PHP shell is currently `image/jpeg`. We'll change this to `text/x-php`, and the file extension from `.jpg` to `.php`, then forward the request to the server:
	
	![](https://i.imgur.com/sqmwssT.png)
	Now, when we navigate to `http://demo.uploadvulns.thm/uploads/shell.php` having set up a netcat listener, we receive a connection from the shell!
	![](https://i.imgur.com/cUqNO2L.png)
 
4. _Send the file directly to the upload point._ Why use the webpage with the filter, when you can send the file directly using a tool like `curl`? Posting the data directly to the page which contains the code for handling the file upload is another effective method for completely bypassing a client side filter. the syntax for such a command would look something like this: `curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>`. To use this method you would first aim to intercept a successful upload (using Burpsuite or the browser console) to see the parameters being used in the upload, which can then be slotted into the above command.

#### Bypassing Server-Side Filtering: File Extensions
https://tryhackme.com/room/uploadvulns#

#### Bypassing Server-Side Filtering: Magic Numbers
magic numbers are used as a more accurate identifier of files. The magic number of a file is a string of hex digits, and is always the very first thing in a file.

e.g:
We can see that the magic number we've chosen is four bytes long, so let's open up the reverse shell script and add four random characters on the first line. These characters do not matter, so for this example we'll just use four "A"s:

![](https://i.imgur.com/oe434wu.png)

Save the file and exit. Next we're going to reopen the file in `hexeditor` (which comes by default on Kali), or any other tool which allows you to see and edit the shell as hex. In hexeditor the file looks like this:

![](https://i.imgur.com/otIyN96.png)

Note the four bytes in the red box: they are all `41`, which is the hex code for a capital "A" -- exactly what we added at the top of the file previously.

Change this to the magic number we found earlier for JPEG files: `FF D8 FF DB`

![](https://i.imgur.com/2OlGKdQ.png)  

Now if we save and exit the file (Ctrl + x), we can use `file` once again, and see that we have successfully spoofed the filetype of our shell:

![](https://i.imgur.com/ldyt88v.png)

